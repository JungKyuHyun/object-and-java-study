# 티켓 판매 애플리케이션

오브젝트

## 기획

- 영화관에서 사용하는 애플리케이션이다. 
- 관객들은 티켓을 소지하고 있어야만, 영화를 볼 수 있다.

## 요구 사항 1

- 무료 관람 초대장 이벤트에 당첨된 관객의 경우, 초대장을 티켓으로 교환한 후에 입장해야 한다.
- 이벤트에 당첨되지 않는 관객은 티켓을 구매해야 입장할 수 있다.
- 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야하며, 당첨자가 아닌 경우 티켓을 판매한 후 입장시켜야 한다.
- 초대 장에는 영화를 관람할 수 있는 초대일자(when)가 포함되어 있다.

---

## 소프트웨어 모듈이 가져야 하는 세 가지 기능

로버트 마틴의 클린 소프트웨어.

1. 첫번째 목적은 실행 중에 제대로 동작하는 것이다.
2. 두번째 목적은 변경을 위해 존재하는 것이다. 변경하기 어려운 모듈은 제대로 동작하더라고 개선해야 한다.
3. 세번째 목적은 코드를 읽는 사람과 의사소통하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.

---

## 현재의 문제점

> 관객과 판매원이 소극장의 통제를 받는 수동적인 존재다. 이해가 안된다면 Theater 클래스의 enter 메서드가 수행하는 일을 말로 풀어보자.

&nbsp;이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다. 
현재까지 작성된 코드는 우리의 예상을 벗어난다. 현재의 코드는 우리의 상식과는 너무나도 다르게 동작하기 때문에 코드를 읽는 사람과 제대로 의사소통하지 못한다.

> Theater의 enter 메서드를 이해하기 위해서는 Audience가 Bag을 가지고 있고, Bag 안에 현금과 티켓이 들어 있으며, TicketSeller가 TicketOffice에서 판매하고, TicketOffice 안에 돈과 티켓이 보관돼 있다는 모든 사실을 동시에 기억하고 있어야 한다.

&nbsp;두번째로 코드를 읽게 어렵게 만드는 이유는, 이 코드를 이해하기 위해서는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다는 점이다. 이 코드는 하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐만 아니라 코드를 일고 이해해야 하는 사람에게 모두 큰 부담을 준다.

> Audience, TicketSellet를 변경할 경우 Theater도 함께 변경해야 한다.

&nbsp; 하지만 가장 큰 문제는 변경에 취약한 코드라는 것이다. 현재 코드의 가정은 아래와 같다.

- 관객은 항상 현금과 초대장을 보관하기 위해 가방을 가지고 다닌다.
- 판매원이 매표소에서만 티켓을 판매한다.

&nbsp;만약 관람객에 가방을 들고 있지 않는다면 어떻게 해야 할까. 현금이 아닌 신용카드를 이용해서 결제한다면 어떻게 해야 할까. 판매원이 매표소 밖에서 티켓을 판매해야 한다면 어떻게 해야 할까. **이런 가정이 깨지는 순간 모든 코드가 일시에 흔들리게 된다.**

&nbsp;이것은 객체 사이의 의존성(`dependency`)과 관련된 문제다. 문제는 의존성이 변경과 관련돼 있다는 점이다. 의존성은 변경에 대한 영향을 암시한다. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다. 

&nbsp;객체 사이의 의존성을 완전히 없애는 것이 정답이 아니다. 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 따라서 우리의 목표는 **애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.** 

&nbsp;객체 사이의 의존성이 과한 경우를 가리켜 결합도(`coupling`)가 높다고 말한다. 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워 진다. **따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다.**
